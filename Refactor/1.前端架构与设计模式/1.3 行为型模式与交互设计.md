# 1.3 行为型模式与交互设计

> 本节梳理行为型设计模式（如观察者、命令、策略、状态、责任链、模板方法、中介者等）在UI/UE/UX、前端交互设计中的典型应用，结合事件驱动、状态管理、策略切换等场景，给出形式化结构、代码示例（Rust/Haskell优先）、本地跳转。

## 目录

- [1.3.1 观察者模式与事件系统](#131-观察者模式与事件系统)
- [1.3.2 命令模式与操作封装](#132-命令模式与操作封装)
- [1.3.3 策略模式与行为切换](#133-策略模式与行为切换)
- [1.3.4 状态模式与UI状态管理](#134-状态模式与ui状态管理)
- [1.3.5 责任链模式与事件分发](#135-责任链模式与事件分发)
- [1.3.6 模板方法与流程规范](#136-模板方法与流程规范)
- [1.3.7 中介者模式与组件协作](#137-中介者模式与组件协作)

---

## 1.3.1 观察者模式与事件系统

- 典型应用：UI事件订阅、响应式数据流、组件间通信。
- Rust 示例：
```rust
trait Observer {
    fn on_notify(&self, msg: &str);
}

struct Button;
impl Button {
    fn click(&self, observer: &dyn Observer) {
        observer.on_notify("Button clicked");
    }
}
```

## 1.3.2 命令模式与操作封装

- 典型应用：UI操作封装、撤销重做、宏命令。
- Rust 示例：
```rust
trait Command {
    fn execute(&self);
}

struct ClickCommand;
impl Command for ClickCommand {
    fn execute(&self) {
        println!("执行点击操作");
    }
}

struct Invoker {
    commands: Vec<Box<dyn Command>>,
}
impl Invoker {
    fn run(&self) {
        for cmd in &self.commands {
            cmd.execute();
        }
    }
}
```

## 1.3.3 策略模式与行为切换

- 典型应用：UI交互策略切换、动画策略、输入法切换。
- Rust 示例：
```rust
trait Strategy {
    fn execute(&self);
}

struct LightTheme;
impl Strategy for LightTheme {
    fn execute(&self) {
        println!("应用浅色主题");
    }
}

struct DarkTheme;
impl Strategy for DarkTheme {
    fn execute(&self) {
        println!("应用深色主题");
    }
}

struct ThemeContext {
    strategy: Box<dyn Strategy>,
}
impl ThemeContext {
    fn set_strategy(&mut self, strategy: Box<dyn Strategy>) {
        self.strategy = strategy;
    }
    fn apply(&self) {
        self.strategy.execute();
    }
}
```

## 1.3.4 状态模式与UI状态管理

- 典型应用：UI组件状态切换、表单校验、流程控制。
- Rust 示例：
```rust
trait State {
    fn handle(&self);
}

struct Enabled;
impl State for Enabled {
    fn handle(&self) {
        println!("组件可用");
    }
}

struct Disabled;
impl State for Disabled {
    fn handle(&self) {
        println!("组件不可用");
    }
}

struct UIControl {
    state: Box<dyn State>,
}
impl UIControl {
    fn set_state(&mut self, state: Box<dyn State>) {
        self.state = state;
    }
    fn request(&self) {
        self.state.handle();
    }
}
```

## 1.3.5 责任链模式与事件分发

- 典型应用：事件冒泡、拦截器链、表单校验链。
- Rust 示例：
```rust
trait Handler {
    fn handle(&self, req: &str) -> bool;
}

struct ClickHandler;
impl Handler for ClickHandler {
    fn handle(&self, req: &str) -> bool {
        if req == "click" {
            println!("处理点击事件");
            true
        } else {
            false
        }
    }
}

struct KeyHandler;
impl Handler for KeyHandler {
    fn handle(&self, req: &str) -> bool {
        if req == "key" {
            println!("处理按键事件");
            true
        } else {
            false
        }
    }
}

struct Chain {
    handlers: Vec<Box<dyn Handler>>,
}
impl Chain {
    fn process(&self, req: &str) {
        for h in &self.handlers {
            if h.handle(req) {
                break;
            }
        }
    }
}
```

## 1.3.6 模板方法与流程规范

- 典型应用：UI渲染流程、表单校验流程、数据处理模板。
- Rust 示例：
```rust
trait Template {
    fn step1(&self);
    fn step2(&self);
    fn run(&self) {
        self.step1();
        self.step2();
    }
}

struct RenderProcess;
impl Template for RenderProcess {
    fn step1(&self) {
        println!("准备数据");
    }
    fn step2(&self) {
        println!("渲染UI");
    }
}
```

## 1.3.7 中介者模式与组件协作

- 典型应用：组件间解耦、事件总线、表单控件协作。
- Rust 示例：
```rust
trait Mediator {
    fn notify(&self, sender: &str, event: &str);
}

struct Dialog<'a> {
    mediator: &'a dyn Mediator,
}

struct ConcreteMediator;
impl Mediator for ConcreteMediator {
    fn notify(&self, sender: &str, event: &str) {
        println!("{} 发送事件: {}", sender, event);
    }
}
``` 