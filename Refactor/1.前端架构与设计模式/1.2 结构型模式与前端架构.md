# 1.2 结构型模式与前端架构

> 本节梳理结构型设计模式（如适配器、桥接、装饰器、外观、组合、享元、代理等）在UI/UE/UX、前端架构中的典型应用，结合组件解耦、接口适配、性能优化等场景，给出形式化结构、代码示例（Rust/Haskell优先）、本地跳转。

## 目录

- [1.2.1 适配器模式与接口兼容](#121-适配器模式与接口兼容)
- [1.2.2 桥接模式与平台解耦](#122-桥接模式与平台解耦)
- [1.2.3 装饰器模式与功能扩展](#123-装饰器模式与功能扩展)
- [1.2.4 外观模式与架构简化](#124-外观模式与架构简化)
- [1.2.5 享元模式与性能优化](#125-享元模式与性能优化)
- [1.2.6 代理模式与权限控制](#126-代理模式与权限控制)

---

## 1.2.1 适配器模式与接口兼容

- 典型应用：前端组件库适配不同API、旧系统兼容新接口、跨平台UI适配。
- Rust 示例：
```rust
trait Target {
    fn request(&self) -> String;
}

struct Adaptee;
impl Adaptee {
    fn specific_request(&self) -> String {
        "特殊请求".to_string()
    }
}

struct Adapter {
    adaptee: Adaptee,
}
impl Target for Adapter {
    fn request(&self) -> String {
        self.adaptee.specific_request()
    }
}
```

## 1.2.2 桥接模式与平台解耦

- 典型应用：UI渲染引擎与平台解耦、主题与组件分离、跨端渲染。
- Rust 示例：
```rust
trait Renderer {
    fn render(&self, content: &str);
}

struct HtmlRenderer;
impl Renderer for HtmlRenderer {
    fn render(&self, content: &str) {
        println!("<div>{}</div>", content);
    }
}

struct CanvasRenderer;
impl Renderer for CanvasRenderer {
    fn render(&self, content: &str) {
        println!("Canvas: {}", content);
    }
}

struct UIElement<'a> {
    renderer: &'a dyn Renderer,
    content: String,
}
impl<'a> UIElement<'a> {
    fn draw(&self) {
        self.renderer.render(&self.content);
    }
}
```

## 1.2.3 装饰器模式与功能扩展

- 典型应用：为UI组件动态添加功能（如日志、权限、样式等）。
- Rust 示例：
```rust
trait Component {
    fn operation(&self);
}

struct ConcreteComponent;
impl Component for ConcreteComponent {
    fn operation(&self) {
        println!("基本操作");
    }
}

struct LoggingDecorator<C: Component> {
    component: C,
}
impl<C: Component> Component for LoggingDecorator<C> {
    fn operation(&self) {
        println!("日志记录");
        self.component.operation();
    }
}
```

## 1.2.4 外观模式与架构简化

- 典型应用：统一UI接口、简化复杂子系统调用、前端API聚合。
- Rust 示例：
```rust
struct SubSystemA;
impl SubSystemA {
    fn do_a(&self) { println!("A模块"); }
}
struct SubSystemB;
impl SubSystemB {
    fn do_b(&self) { println!("B模块"); }
}

struct Facade {
    a: SubSystemA,
    b: SubSystemB,
}
impl Facade {
    fn operation(&self) {
        self.a.do_a();
        self.b.do_b();
        println!("统一接口");
    }
}
```

## 1.2.5 享元模式与性能优化

- 典型应用：UI元素复用、虚拟DOM、图标池、样式缓存。
- Rust 示例：
```rust
use std::collections::HashMap;

struct Icon {
    name: String,
}

struct IconFactory {
    icons: HashMap<String, Icon>,
}
impl IconFactory {
    fn get_icon(&mut self, name: &str) -> &Icon {
        self.icons.entry(name.to_string()).or_insert(Icon { name: name.to_string() })
    }
}
```

## 1.2.6 代理模式与权限控制

- 典型应用：UI操作权限、远程调用、懒加载、缓存代理。
- Rust 示例：
```rust
trait Service {
    fn execute(&self);
}

struct RealService;
impl Service for RealService {
    fn execute(&self) {
        println!("执行真实服务");
    }
}

struct ProxyService {
    real: RealService,
    has_permission: bool,
}
impl Service for ProxyService {
    fn execute(&self) {
        if self.has_permission {
            self.real.execute();
        } else {
            println!("无权限");
        }
    }
}
``` 