# 1.1 GoF设计模式与UI组件化

> 本节梳理GoF设计模式在UI/UE/UX、前端组件化中的典型应用，结合实际前端架构与组件开发场景，给出形式化结构、代码示例（Rust/Haskell优先）、本地跳转。

## 目录

- [1.1.1 单例模式与全局状态管理](#111-单例模式与全局状态管理)
- [1.1.2 工厂方法与组件生成](#112-工厂方法与组件生成)
- [1.1.3 装饰器模式与UI扩展](#113-装饰器模式与ui扩展)
- [1.1.4 观察者模式与事件驱动](#114-观察者模式与事件驱动)
- [1.1.5 组合模式与组件树](#115-组合模式与组件树)

---

## 1.1.1 单例模式与全局状态管理

- 典型应用：全局主题、配置、UI状态管理（如全局Store、Context等）。
- Rust 示例：
```rust
use once_cell::sync::Lazy;
use std::sync::Mutex;

static GLOBAL_THEME: Lazy<Mutex<Theme>> = Lazy::new(|| {
    Mutex::new(Theme::default())
});

#[derive(Debug, Default)]
struct Theme {
    color: String,
}
```

## 1.1.2 工厂方法与组件生成

- 典型应用：动态UI组件生成、表单工厂、弹窗工厂等。
- Rust 示例：
```rust
trait Component {
    fn render(&self) -> String;
}

struct Button;
impl Component for Button {
    fn render(&self) -> String {
        "<button>Click</button>".to_string()
    }
}

struct ComponentFactory;
impl ComponentFactory {
    fn create_button() -> Button {
        Button
    }
}
```

## 1.1.3 装饰器模式与UI扩展

- 典型应用：为组件动态添加功能（如权限、样式、动画等）。
- Rust 示例：
```rust
trait Widget {
    fn draw(&self);
}

struct TextField;
impl Widget for TextField {
    fn draw(&self) {
        println!("绘制文本框");
    }
}

struct BorderDecorator<W: Widget> {
    widget: W,
}
impl<W: Widget> Widget for BorderDecorator<W> {
    fn draw(&self) {
        self.widget.draw();
        println!("绘制边框");
    }
}
```

## 1.1.4 观察者模式与事件驱动

- 典型应用：UI事件系统、数据响应式、订阅-发布等。
- Rust 示例：
```rust
trait Observer {
    fn on_notify(&self, msg: &str);
}

struct Button;
impl Button {
    fn click(&self, observer: &dyn Observer) {
        observer.on_notify("Button clicked");
    }
}
```

## 1.1.5 组合模式与组件树

- 典型应用：UI组件树、DOM树、分层视图结构。
- Rust 示例：
```rust
trait UIComponent {
    fn render(&self);
}

struct Panel {
    children: Vec<Box<dyn UIComponent>>,
}
impl UIComponent for Panel {
    fn render(&self) {
        for child in &self.children {
            child.render();
        }
        println!("渲染面板");
    }
}
``` 