# 1.1 GoF设计模式与UI组件化

> 本节梳理GoF设计模式在UI/UE/UX、前端组件化中的典型应用，结合实际前端架构与组件开发场景，给出形式化结构、代码示例（Rust/Haskell优先）、本地跳转。

## 目录

- [1.1 GoF设计模式与UI组件化](#11-gof设计模式与ui组件化)
  - [目录](#目录)
  - [1.1.1 单例模式与全局状态管理](#111-单例模式与全局状态管理)
  - [1.1.2 工厂方法与组件生成](#112-工厂方法与组件生成)
  - [1.1.3 装饰器模式与UI扩展](#113-装饰器模式与ui扩展)
  - [1.1.4 观察者模式与事件驱动](#114-观察者模式与事件驱动)
  - [1.1.5 组合模式与组件树](#115-组合模式与组件树)

---

## 1.1.1 单例模式与全局状态管理

- 单例模式常用于全局主题、配置、用户会话等UI状态的唯一性保证。
- 典型场景：全局Store（如Redux、MobX）、React Context、全局主题切换。
- 设计要点：线程安全、惰性初始化、生命周期管理。
- Rust实现强调静态生命周期与线程安全（见once_cell示例）。
- Haskell中可用IORef/MVar实现全局状态，但需注意纯函数式副作用隔离。

## 1.1.2 工厂方法与组件生成

- 工厂方法模式适合动态生成UI组件、表单元素、弹窗等。
- 典型场景：表单工厂、弹窗工厂、动态路由组件。
- 设计要点：解耦组件创建与使用、支持多样化组件扩展。
- Rust中可用trait对象实现多态组件工厂。
- Haskell中可用类型类和ADT实现组件生成。

## 1.1.3 装饰器模式与UI扩展

- 装饰器模式用于为组件动态添加功能，如权限、样式、动画、日志等。
- 典型场景：高阶组件（HOC）、中间件、样式装饰、功能增强。
- 设计要点：保持原有接口、可组合、可链式调用。
- Rust中通过泛型和trait实现装饰器链。
- Haskell中可用函数组合和Monad Transformer实现。

## 1.1.4 观察者模式与事件驱动

- 观察者模式是UI事件系统、响应式数据流、订阅-发布的基础。
- 典型场景：事件总线、数据绑定、响应式UI、消息通知。
- 设计要点：解耦事件源与监听者、支持多订阅者、异步事件分发。
- Rust中可用channel、trait对象实现事件分发。
- Haskell中可用FRP库（如reflex）实现响应式事件流。

## 1.1.5 组合模式与组件树

- 组合模式适合UI组件树、DOM树、分层视图结构的递归组织。
- 典型场景：React/Vue组件树、虚拟DOM、分层菜单、树形控件。
- 设计要点：统一叶子与容器接口、递归渲染、灵活扩展。
- Rust中可用`Box<dyn Trait>`递归定义树结构。
- Haskell中可用递归数据类型和Functor实现树遍历。
