# 1.4 游戏端

> 本文档归档所有游戏端UI/UE/UX架构、技术栈、设计模式、性能优化等相关内容。

## 目录

- [1.4 游戏端](#14-游戏端)
  - [目录](#目录)
    - [1.4.1 游戏引擎与技术栈](#141-游戏引擎与技术栈)
    - [1.4.2 游戏UI架构与设计模式](#142-游戏ui架构与设计模式)
    - [1.4.3 性能优化与工程实践](#143-性能优化与工程实践)
    - [1.4.4 UI/UX 设计原则](#144-uiux-设计原则)

---

### 1.4.1 游戏引擎与技术栈

游戏开发高度依赖于特定的游戏引擎，这些引擎提供了渲染、物理、音频和UI的整套解决方案。

| 游戏引擎 | 主要编程语言 | UI解决方案 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **Unreal Engine** | C++ | Unreal Motion Graphics (UMG) | 图形效果顶级、蓝图系统强大、社区资源丰富 | 学习曲线陡峭、对硬件要求高 |
| **Unity** | C# | Unity UI, UI Toolkit | 跨平台能力强、生态成熟、易于上手 | 性能和图形上限低于Unreal、源码不开放 |
| **Godot** | GDScript, C#, C++ | Control Nodes | 开源免费、轻量级、节点式场景系统直观 | 3D性能相对较弱、商业大作案例少 |
| **Bevy** | Rust | Bevy UI (基于ECS) | 数据驱动（ECS）、内存安全、现代化、社区驱动 | 非常年轻、生态不成熟、功能仍在快速迭代 |

- **相关语言范式**:
  - `C++`: Unreal Engine 的核心。
  - `C#`: Unity 的主要脚本语言。
  - `Rust`: Bevy 等新兴引擎的选择，[详情参考](../3.编程语言范式/3.1%20Rust.md)。

### 1.4.2 游戏UI架构与设计模式

游戏UI系统需要处理复杂的状态、动画和交互，对架构有很高的要求。

- **实体-组件-系统 (ECS - Entity Component System)**:
  - `Bevy` 等现代引擎的核心架构。UI元素（如按钮、面板）作为实体，其属性（如位置、颜色）作为组件，逻辑（如点击事件处理）由系统处理。
  - **优点**: 高性能、数据和逻辑分离、易于并行化。

- **模型-视图-视图模型 (MVVM)**:
  - 在Unity等引擎中广泛应用，通过 `UniRx` 等响应式编程框架实现。
  - **模型(Model)**: 游戏状态数据。
  - **视图(View)**: UI元素（Unity中的GameObject）。
  - **视图模型(ViewModel)**: 连接模型和视图，处理UI逻辑。
  - **优点**: 结构清晰、可测试性强、UI与游戏逻辑解耦。

### 1.4.3 性能优化与工程实践

游戏UI的性能直接影响玩家体验。

- **渲染优化**:
  - **Draw Call 合并**: 使用 `Atlas`（图集）或 `Sprite Sheet` 将多个UI纹理合并，减少渲染批次。
  - **Overdraw (过度绘制) 优化**: 避免透明UI元素的大面积重叠。
  - **UI 裁剪 (Culling)**: 只渲染视口内的UI元素。
- **内存管理**:
  - **资源池化 (Pooling)**: 对频繁创建和销毁的UI元素（如特效、列表项）进行复用。
  - **按需加载**: 只在需要时加载UI资源。
- **工程实践**:
  - **UI预制件/蓝图 (Prefabs/Blueprints)**: 实现UI组件的可复用性。
  - **可视化脚本**: 使用蓝图(Unreal)或类似系统，方便设计师调整UI逻辑。

### 1.4.4 UI/UX 设计原则

游戏UI/UX不仅要美观，更要服务于游戏玩法。

- **沉浸感 (Immersion)**: UI设计应与游戏的世界观、美术风格保持一致，避免让玩家"出戏"。
- **信息清晰度**: 在复杂的战斗或信息界面中，能让玩家快速获取核心信息（如生命值、弹药）。
- **反馈及时性**: 玩家的每一个操作都应有清晰、及时的视觉或听觉反馈。
- **可访问性 (Accessibility)**: 提供色盲模式、字幕大小调整、按键重映射等功能，让更多玩家能够享受游戏。
