# 2.3 Rust 前端全栈

> 本文档归档并分析基于 Rust 语言构建前端及全栈应用的技术栈，核心在于其通过 WebAssembly (Wasm) 实现的高性能与内存安全特性。

## 目录

- [2.3 Rust 前端全栈](#23-rust-前端全栈)
  - [目录](#目录)
    - [2.3.1 Rust WebAssembly (Wasm) 框架对比](#231-rust-webassembly-wasm-框架对比)
    - [2.3.2 核心优势：性能与安全](#232-核心优势性能与安全)
    - [2.3.3 全栈架构：前后端同构](#233-全栈架构前后端同构)
    - [2.3.4 工具链与生态](#234-工具链与生态)

---

### 2.3.1 Rust WebAssembly (Wasm) 框架对比

这些框架允许开发者使用 Rust 构建可直接在浏览器中运行的 Web 应用。

| 框架 | 渲染模式 | 核心思想 | 灵感来源 | 状态管理 |
| :--- | :--- | :--- | :--- | :--- |
| **Yew** | VDOM (虚拟DOM) | 类React的组件模型，宏驱动 | React | 基于组件的 state 和 props |
| **Dioxus** | VDOM (虚拟DOM) | "Write once, run anywhere" (一次编写，随处运行) | React | Hooks API (受React启发) |
| **Leptos** | Fine-grained (细粒度响应) | 无虚拟DOM，基于信号(Signal)的响应式系统 | SolidJS | Signals (信号) |
| **Sycamore** | Fine-grained (细粒度响应) | 无虚拟DOM，基于信号(Signal)的响应式系统 | SolidJS | Signals (信号) |

- **相关主题**: [WebAssembly 技术解析](../2.技术栈与框架/2.5%20WebAssembly.md)

### 2.3.2 核心优势：性能与安全

- **性能**:
  - **零成本抽象**: Rust 的特性（如所有权、生命周期）在编译时强制执行，运行时开销极小。
  - **Wasm 执行效率**: WebAssembly 作为二进制格式，其解码和执行速度远快于 JavaScript。
  - **无GC暂停**: 与 JavaScript 不同，Rust/Wasm 应用不受垃圾回收(GC)导致的随机暂停影响，对实时应用和游戏非常有利。
- **安全**:
  - **内存安全**: Rust 的所有权和借用检查机制从根本上杜绝了空指针、野指针、数据竞争等内存安全问题。
  - **类型安全**: 强大的静态类型系统确保了代码的健壮性。

### 2.3.3 全栈架构：前后端同构

Rust 使前后端使用同一门语言、共享代码逻辑成为可能。

- **服务端框架**:
  - **Axum**: 高度模块化、符合人体工程学的Web框架，与 `Tokio` 生态深度集成。
  - **Actix Web**: 以高性能和实用性著称的Web框架。
- **代码共享**:
  - **类型定义**: 前后端可共享数据结构（`struct`）和API接口定义，避免了API对接时的不一致问题。
  - **业务逻辑**: 验证、数据处理等纯逻辑代码可以在服务器和客户端之间复用。
- **服务端渲染 (SSR)**:
  - `Leptos` 和 `Dioxus` 等现代框架内置了对SSR的支持，允许在服务器上渲染首屏，提升SEO和用户体验。

### 2.3.4 工具链与生态

- **构建与打包**:
  - `wasm-pack`: 用于打包Rust代码为Wasm模块，并生成与JavaScript的互操作层。
  - `trunk`: 一个用于Rust Wasm应用的打包器和开发服务器，提供热重载等功能。
- **与JS互操作**:
  - `wasm-bindgen`: 促进Wasm模块与JavaScript之间的数据类型和函数调用转换。
- **相关语言范式**: [Rust 编程语言范式](../3.编程语言范式/3.1%20Rust.md)
